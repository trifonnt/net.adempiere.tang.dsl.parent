/*
 * generated by Xtext 2.12.0
 */
package net.adempiere.tang.dsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import net.adempiere.tang.dsl.tang.TangEntity
import net.adempiere.tang.dsl.tang.TangPackageDeclaration
import com.google.inject.Inject
import org.eclipse.xtext.naming.IQualifiedNameProvider
import net.adempiere.tang.dsl.tang.Field
import net.adempiere.tang.dsl.tang.TangType
import net.adempiere.tang.dsl.tang.TangAbstractEntity
import net.adempiere.tang.dsl.tang.TangAbstractType
import net.adempiere.tang.dsl.tang.BasicType
import net.adempiere.tang.dsl.tang.SubType
import net.adempiere.tang.dsl.tang.BasicIntegerType
import net.adempiere.tang.dsl.tang.BasicStringType
import net.adempiere.tang.dsl.tang.SubStringType

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class TangGenerator extends AbstractGenerator {

	//@Trifon
	@Inject
	extension IQualifiedNameProvider

	@Inject // @Trifon
	extension TangAbstractTypeToJavaTypeConverter javaTypeRepresentation;

	@Inject // @Trifon
	extension TangAbstractTypeToDbTypeConverter dbTypeRepresentation;

	@Inject // @Trifon
	extension StringUtils stringUtils;

	@Inject // @Trifon
	extension TangTypeUtils tangTypeUtils;

	@Inject
	extension IsQuotationMarkRequiredDecisionMaker quotationMarkRequiredDecisionMaker;


	String comma = ""; // GLOBAL field to store if comma is already used! I did not found another way to solve it!!!


	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		//+01) Generate tiny documentation.
		for (tangPackage : resource.allContents.toIterable.filter(TangPackageDeclaration)) {
//			val fileName = 'all-entities--'+ tangPackage.fullyQualifiedName +'.txt';

//src-gen/all-entities--/resource/tangdsl-sample-project-01/03_entities.tang.txt
//			val fileName = 'all-entities--'+ resource.URI.path +'.txt';

// src-gen/all-entities--03_entities.tang.txt
			val fileName = 'all-entities--'+ resource.URI.lastSegment +'.txt';
			fsa.generateFile(fileName, 'Entities in our System: ' + 
				tangPackage.elements
					.filter(TangEntity)
					.map[name]
					.join(', ')
			);
		}


		//+02) Generate Java Beans(JPA Entities)
		for (tangPackage : resource.allContents.toIterable.filter(TangPackageDeclaration)) {
			for (entity : tangPackage.elements.filter(TangEntity)) {
				fsa.generateFile(
//					tangPackage.name + '/' + entity.name +'.java'
					"src/main/java/" + entity.fullyQualifiedName.toString("/") + ".java"
//					, "public class "+entity.name + " { }"
					, entity.generateJavaDomainClass
				)
			}
		}

		// TODO
		//-03) Generate XML file with DB Migration(Liquibase)
		for (tangPackage : resource.allContents.toIterable.filter(TangPackageDeclaration)) {
			for (entity : tangPackage.elements.filter(TangEntity)) {
				fsa.generateFile(
					"src/main/resources/config/liquibase/changelog/" +	entity.name + ".liquibase.xml" // entity.fullyQualifiedName.toString("/") + ".liquibase.xml"
					, entity.generateLiquibaseFile
				)
			}
		}

		// TODO
		//-04) Generate finders(Java interfaces) for Spring repository 


		// TODO - finish this generation!
		//-05) Generate DTO classes
		for (tangPackage : resource.allContents.toIterable.filter(TangPackageDeclaration)) {
			for (entity : tangPackage.elements.filter(TangEntity)) {
				fsa.generateFile(
					"src/main/java/" + tangPackage.name.replaceAll("\\.", "/") + "/service/dto/" + entity.name +"DTO.java"
//				"src/main/java/" + entity.fullyQualifiedName.toString("/") + "DTO.java"
					, entity.generateJavaDTOClass
				)
			}
		}

	}

	def generateJavaDTOClass(TangEntity entity) {
		'''
		«IF entity.eContainer.fullyQualifiedName !== null»
		package «entity.eContainer.fullyQualifiedName».service.dto;
		
		«ENDIF»
		import java.io.Serializable;
		import java.util.Objects;
		import javax.validation.constraints.*;
		
		public class «entity.name»DTO «IF entity.superEntity !== null»extends «entity.superEntity.fullyQualifiedName» «ENDIF»implements Serializable {
		
			private static final long serialVersionUID = 1L;
		«FOR field: entity.fields»
		
			«generateJavaFieldValidationAnnotations(field)»
			«generateJavaField(field)»
		«ENDFOR»

		«FOR field: entity.fields»
			«generateJavaGetterAndSetter(field)»
		«ENDFOR»
		
		«generateJavaDTOClassEqualsMethod(entity)»
		
		«generateJavaHashCodeMethod(entity)»
		
		«generateJavaToStringMethod(entity, "DTO")»
		}
		'''
	}

	def generateJavaDomainClass(TangEntity entity) {
		'''
		«IF entity.eContainer.fullyQualifiedName !== null»
		package «entity.eContainer.fullyQualifiedName»;
		
		«ENDIF»
		import com.fasterxml.jackson.annotation.JsonIgnore;
		import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
		import org.hibernate.annotations.Cache;
		import org.hibernate.annotations.CacheConcurrencyStrategy;
		
		import javax.persistence.*;
		import javax.validation.constraints.*;
		
		import org.springframework.data.elasticsearch.annotations.Document;
		import java.io.Serializable;
		import java.util.HashSet;
		import java.util.Set;
		import java.util.Objects;
		
		@Entity
		@Table(name = "«entity.tableName.removeQuotes»")
		@Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
		@Document(indexName = "«entity.name.toLowerCase»")
		public class «entity.name» «IF entity.superEntity !== null»extends «entity.superEntity.fullyQualifiedName» «ENDIF»implements Serializable {
		
			private static final long serialVersionUID = 1L;
		«FOR field: entity.fields»
		
			«generateJavaFieldValidationAnnotations(field)»
			«generateJavaEntityFieldAnnotations(entity, field)»
			«generateJavaField(field)»
		«ENDFOR»

		«FOR field: entity.fields»
			«generateJavaGetterAndSetter(field)»
		«ENDFOR»

		«generateJavaDomainClassEqualsMethod(entity)»
		
		«generateJavaHashCodeMethod(entity)»
		
		«generateJavaToStringMethod(entity, "")»
		}
		'''
	}

	def generateJavaDTOClassEqualsMethod(TangEntity entity) {
'''	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (o == null || getClass() != o.getClass()) {
			return false;
		}

		«entity.name»DTO «entity.name.toFirstLower»DTO = («entity.name»DTO) o;
		if («entity.name.toFirstLower»DTO.getId() == null || getId() == null) {
			return false;
		}
		return Objects.equals(getId(), «entity.name.toFirstLower»DTO.getId());
	}
'''
	}

	def generateJavaDomainClassEqualsMethod(TangEntity entity) {
'''	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (o == null || getClass() != o.getClass()) {
			return false;
		}

		«entity.name» «entity.name.toFirstLower» = («entity.name») o;
		if («entity.name.toFirstLower».getId() == null || getId() == null) {
			return false;
		}
		return Objects.equals(getId(), «entity.name.toFirstLower».getId());
	}
'''
	}

	def generateJavaHashCodeMethod(TangEntity entity) {
'''	@Override
	public int hashCode() {
		return Objects.hashCode(getId());
	}
'''
	}

	def generateJavaToStringMethod(TangEntity entity, String suffix) {
//		var String comma = "";
		comma = ""; // nullify COMMA before usage!
'''	@Override
	public String toString() {
		return "«entity.name»«suffix» {" +
		«FOR field: entity.fields»
			«generateJavaToStringField(field)»
		«ENDFOR»
		"}";
	}
'''
	}
	def generateJavaToStringField(Field field) {
		var quotationMark = "";
		var quotationMarkAndPlus = "";
		if (field.fieldType.isQuotationMarkRequired) {
			quotationMark = "'";
			quotationMarkAndPlus = " \"'\" +";
		}
		
		var result = 
'''	"«comma»«field.name»=«quotationMark»" + get«field.name.toFirstUpper»() +«quotationMarkAndPlus»
'''
		// Set proper value of COMMA
		if (comma.empty) {
			comma = ", ";
		}
		return result;
	}


	def generateJavaEntityFieldAnnotations(TangEntity entity, Field field) {
		var String result = null;
		var nullable = "";
		var unique = "";

		if (field.fieldType instanceof TangType) {
			val fieldType = field.fieldType as TangType;
			if (fieldType.allowNull) {
				// ignore
			} else {
				nullable = ", nullable = false";
			}

			if (field?.defaultCalculationMethod?.defaultValueConstant !== null) {
				unique = ", unique = true";
			}

			result = "@Column(name = \""+field.columnName+"\"" + nullable + unique +")";
		}
		return result;
	}

	def generateJavaFieldValidationAnnotations(Field field) {
		var String result = null;
		if (field.fieldType instanceof TangType) {
			val fieldType = field.fieldType as TangType;
			if (!fieldType.allowNull) {
				result = "@NotNull";
			}
		}
		return result;
	}

	def generateJavaField(Field field) {
		var defaultValue = "";
		if (field?.defaultCalculationMethod?.defaultValueConstant !== null) {
			defaultValue = " = " + field?.defaultCalculationMethod?.defaultValueConstant;
		} else {
			// Read default value from fieldType
			if (field.fieldType instanceof BasicType) {
				val fieldType = field.fieldType as BasicType;
				if (fieldType.extractDefaultValue !== null) {
					defaultValue = " = " + fieldType.extractDefaultValue.toString;
				}
			}
			if (field.fieldType instanceof SubType) {
				val fieldType = field.fieldType as SubType;
				if (fieldType.extractDefaultValue !== null) {
					defaultValue = " = " + fieldType.extractDefaultValue.toString;
				}
			}
			
		}
		
		var result = 
		'''
			private «IF field.fieldType instanceof TangAbstractEntity»transient «ENDIF»«field.fieldType.toJavaType» «field.name»«defaultValue»;
			«IF field.fieldType instanceof TangAbstractEntity»
			«val fieldType = field.fieldType as TangAbstractEntity»
			private «fieldType.toJavaTypeOfPrimaryKey» «field.name»Id;
			«ENDIF»
		'''
		return result;
	}
	def generateJavaGetterAndSetter(Field f) {
		'''
		
			public «f.fieldType.toJavaType» get«f.name.toFirstUpper»() {
				return «f.name»;
			}
			public void set«f.name.toFirstUpper»(«f.fieldType.toJavaType» «f.name») {
				this.«f.name» = «f.name»;
			}
		«IF f.fieldType instanceof TangAbstractEntity»
		«val fieldType = f.fieldType as TangAbstractEntity»
			public «fieldType.toJavaTypeOfPrimaryKey» get«f.name.toFirstUpper»Id() {
				return «f.name»Id;
			}
		«ENDIF»
		'''
	}

	def getFieldType(TangType tangType) {
//		if (tangType) {
			
//		}
	}

	def generateLiquibaseFile(TangEntity entity) {
		'''
		<?xml version="1.0" encoding="utf-8"?>
		<databaseChangeLog
			xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
			xmlns:ext="http://www.liquibase.org/xml/ns/dbchangelog-ext"
			xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.9.xsd
													http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd">
		
			<property name="now" value="now()" dbms="h2"/>
		
			<property name="now" value="current_timestamp" dbms="postgresql"/>
		
			<property name="floatType" value="float4" dbms="postgresql, h2"/>
			<property name="floatType" value="float" dbms="mysql, oracle, mssql"/>
		
			<changeSet author="TrifonTrifonov" id="createTable-«entity.tableName.removeQuotes»">
				<createTable tableName=«entity.tableName»>
		«FOR field: entity.fields»
			«field.generateLiquibaseColumn»
		«ENDFOR»
				</createTable>
		«IF entity.primaryKey !== null»
			«entity.generateLiquibasePrimaryKey»
		«ENDIF»
			</changeSet>
		</databaseChangeLog>
		'''
	}
//«val fieldType = f.fieldType as TangAbstractType»
	def generateLiquibaseColumn(Field f) {
		var result = '''''';
		var nullable = false;
		if (f.fieldType instanceof TangAbstractType && f.fieldType instanceof TangType && (f.fieldType instanceof BasicType || f.fieldType instanceof SubType)) {

			if (f.fieldType instanceof SubType) {
				val fieldType = f.fieldType as SubType;
				if (fieldType.allowNull) {
					nullable = true;
				}
			} else {
				val fieldType = f.fieldType as BasicType;
				if (fieldType.allowNull) {
					nullable = true;
				}
			}
			
			if (f.fieldType instanceof BasicIntegerType) {
				val fieldType = f.fieldType as BasicIntegerType;
				fieldType.defaultValue
			}
		}
		result = '''			<column name="«f.columnName»" type="«f.fieldType.toDbType»">
				<constraints nullable="«nullable»" />
			</column>
		'''
		return result;
	}

	def generateLiquibasePrimaryKey(TangEntity entity) {
		var primaryKeyNames = entity.primaryKey.fields
//					.filter(TangEntity)
					.map[columnName]
					.join(', ');
		var primaryKeyName = entity.primaryKey.name;
		'''		<addPrimaryKey 
			columnNames="«primaryKeyNames»"
			constraintName="«primaryKeyName»"
			tableName="«entity.tableName.removeQuotes»"
			validate="true"/>
		'''
	}

}
